一般求子串的题目可以考虑用滑动窗口求解。

对于一个起点，尽可能的向右边拓展，除非当前字符在窗口中出现过。

假如当前起点为`i`，能够拓展的最远边界为`j`，第`j`个字符和第`k`(`i < k < j`)个字符重复。

按照滑动窗口的方法，这时候需要移动左边界。问题来了，要把左边界移动到哪里呢？

很明显需要把左边界移动到`k + 1`的位置，原因如下：

1. 如果移动到`k + 1`左边的位置，最后的窗口都不会比之前的窗口更大。

2. 如果移动到`k + 1`右边的位置，就会漏掉`k + 1`这种情况。

第二个问题是如何判断当前字符在窗口中出现过。我们用`map`存储一个值在数组中出现的位置。

如果当前字符在`map`中已经存在了，就可以知道在窗口中曾经出现过。

同时根据`map`的值，我们还可以知道当前字符在窗口中第一次出现的位置`k`，然后把左边界移动到`k + 1`的位置。

需要注意的是`l = max(mp[s[r]] + 1, l);`这一句代码。

即便一个字符在`map`中出现过，也不能说明这个字符在窗口中出现过。因为我们在移动左边界的时候，并没有将左边界的字符从`map`中去除。

所以一个字符在窗口中出现过需要满足两个条件：1. 这个字符在`map`中出现过。2. 这个字符在`map`中对应的位置大于等于`l`。

```
class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        int ans = 0;
        unordered_map<int, int> mp;
        for (int l = 0, r = 0; r < (int)s.size(); ++r)
        {
            /* 如果右边界的字符在窗口内出现过则调整左边界 */
            if (mp.count(s[r]))
            {
                /* 如果mp[s[r]] + 1 < l, 说明右边界的字符并没有在窗口内出现过 */
                l = max(mp[s[r]] + 1, l);
            }
            mp[s[r]] = r;
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```
